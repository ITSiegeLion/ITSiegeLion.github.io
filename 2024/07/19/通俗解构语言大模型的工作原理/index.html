<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="通俗解构语言大模型的工作原理"><meta name="keywords" content=""><meta name="author" content="Liusf"><meta name="copyright" content="Liusf"><title>通俗解构语言大模型的工作原理 | Hexo</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '7.3.0'
} </script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E3%80%81%E8%AF%8D%E5%90%91%E9%87%8F"><span class="toc-number">1.</span> <span class="toc-text">1、词向量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E3%80%81%E8%AF%8D%E7%9A%84%E6%84%8F%E4%B9%89%E5%8F%96%E5%86%B3%E4%BA%8E%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">2.</span> <span class="toc-text">2、词的意义取决于上下文</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E3%80%81%E5%B0%86%E8%AF%8D%E5%90%91%E9%87%8F%E8%BD%AC%E5%8C%96%E4%B8%BA%E8%AF%8D%E9%A2%84%E6%B5%8B"><span class="toc-number">3.</span> <span class="toc-text">3、将词向量转化为词预测</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E3%80%81%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6"><span class="toc-number">4.</span> <span class="toc-text">4、注意力机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E3%80%81%E4%B8%80%E4%B8%AA%E7%9C%9F%E5%AE%9E%E4%B8%96%E7%95%8C%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">5.</span> <span class="toc-text">5、一个真实世界的例子</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6%E3%80%81%E5%89%8D%E9%A6%88%E6%AD%A5%E9%AA%A4"><span class="toc-number">6.</span> <span class="toc-text">6、前馈步骤</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7%E3%80%81%E4%BD%BF%E7%94%A8%E5%90%91%E9%87%8F%E8%BF%90%E7%AE%97%E8%BF%9B%E8%A1%8C%E5%89%8D%E9%A6%88%E7%BD%91%E7%BB%9C%E7%9A%84%E6%8E%A8%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">7、使用向量运算进行前馈网络的推理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E3%80%81%E6%B3%A8%E6%84%8F%E5%8A%9B%E5%B1%82%E5%92%8C%E5%89%8D%E9%A6%88%E5%B1%82%E6%9C%89%E4%B8%8D%E5%90%8C%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">8.</span> <span class="toc-text">8、注意力层和前馈层有不同的功能</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9%E3%80%81%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AE%AD%E7%BB%83%E6%96%B9%E5%BC%8F"><span class="toc-number">9.</span> <span class="toc-text">9、语言模型的训练方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10%E3%80%81GPT-3-%E7%9A%84%E6%83%8A%E4%BA%BA%E6%80%A7%E8%83%BD"><span class="toc-number">10.</span> <span class="toc-text">10、GPT-3 的惊人性能</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://liusf.site/PicGo/202407182200346.jpg?imageSlim"></div><div class="author-info__name text-center">Liusf</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">6</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">2</span></a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Hexo</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/music">Music</a></span><span class="pull-right"></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">通俗解构语言大模型的工作原理</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2024-07-19</time><span class="post-meta__separator">|</span><i class="fa fa-inbox" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/AI/"> AI</a></div><div class="article-container" id="post-content"><p><em>原文地址：**<a target="_blank" rel="noopener" href="https://www.understandingai.org/p/large-language-models-explained-with">https://www.understandingai.org/p/large-language-models-explained-with</a></em><br><em>译文地址：**<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/21V8g_7teuRgHLWUej1NzA">https://mp.weixin.qq.com/s/21V8g_7teuRgHLWUej1NzA</a></em></p>
<p>语言大模型内部究竟是如何工作的？本文用最少的数学知识和术语进行解释。</p>
<p>本文作者 Tim Lee 曾任职科技媒体 Ars Technica，他近期推出了一份 Newsletter《Understanding AI》，主要探讨人工智能的工作原理。Sean Trott 是加利福尼亚大学圣迭戈分校助理教授，他在研究人类语言理解和语言模型。</p>
<p>当 ChatGPT 在去年秋天推出时，在科技行业乃至世界范围内引起了轰动。当时，机器学习研究人员尝试研发了多年的语言大模型（LLM），但普通大众并未十分关注，也没有意识到它们变得多强大。</p>
<p>如今，几乎每个人都听说过 LLM，并有数千万人用过它们，但是，了解工作原理的人并不多。你可能听说过，训练 LLM 是用于“预测下一个词”，而且它们需要大量的文本来实现这一点。但是，解释通常就止步于此。它们如何预测下一个词的细节往往被视为一个深奥的谜题。</p>
<p>其中一个原因是，这些系统的开发方式与众不同。一般的软件是由人类工程师编写，他们为计算机提供明确的、逐步的指令。相比之下，ChatGPT 是建立在一个使用数十亿个语言词汇进行训练的神经网络之上。 因此，地球上没有人完全理解 LLM 的内部工作原理。研究人员正在努力尝试理解这些模型，但这是一个需要数年甚至几十年才能完成的缓慢过程。</p>
<p>然而，专家们确实对这些系统的工作原理已有不少了解。本文的目标是将这些知识开放给广大受众。我们将努力解释关于这些模型内部工作原理的已知内容，而不涉及技术术语或高级数学。</p>
<p>我们将从解释词向量（word vector）开始，它是语言模型表示和推理语言的一种令人惊讶的方式。然后，我们将深入探讨构建 ChatGPT 等模型的基石 Transformer。最后，我们将解释这些模型是如何训练的，并探讨为什么要使用庞大的数据量才能获得良好的性能。</p>
<h1 id="1、词向量"><a href="#1、词向量" class="headerlink" title="1、词向量"></a>1、词向量</h1><p>要了解语言模型的工作原理，首先需要了解它们如何表示单词。人类用字母序列来表示英文单词，比如 C-A-T 表示猫。语言模型使用的是一个叫做词向量的长串数字列表。例如，这是一种将猫表示为向量的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0.0074, 0.0030, -0.0105, 0.0742, 0.0765, -0.0011, 0.0265, 0.0106, 0.0191, 0.0038, -0.0468, -0.0212, 0.0091, 0.0030, -0.0563, -0.0396, -0.0998, -0.0796, …, 0.0002]</span><br><span class="line">（注：完整的向量长度实际上有 300 个数字）</span><br></pre></td></tr></table></figure>

<p>为什么要使用如此复杂的表示法？这里有个类比，华盛顿特区位于北纬 38.9 度，西经 77 度，我们可以用向量表示法来表示：</p>
<ul>
<li>华盛顿特区的坐标是[38.9，77]</li>
<li>纽约的坐标是[40.7，74]</li>
<li>伦敦的坐标是[51.5，0.1]</li>
<li>巴黎的坐标是[48.9，-2.4]</li>
</ul>
<p>这对于推理空间关系很有用。你可以看出，纽约离华盛顿特区很近，因为坐标中 38.9 接近 40.7，77 接近 74。同样，巴黎离伦敦也很近。但巴黎离华盛顿特区很远。</p>
<p>语言模型采用类似的方法：每个词向量代表了“词空间（word space）”中的一个点，具有相似含义的词的位置会更接近彼此。例如，在向量空间中与猫最接近的词包括狗、小猫和宠物。用实数向量表示单词（相对于“C-A-T”这样的字母串）的一个主要优点是，数字能够进行字母无法进行的运算。</p>
<p>单词太复杂，无法仅用二维表示，因此语言模型使用具有数百甚至数千维度的向量空间。人类无法想象具有如此高维度的空间，但计算机完全可以对其进行推理并产生有用的结果。</p>
<p>几十年来，研究人员一直在研究词向量，但这个概念真正引起关注是在 2013 年，那时 Google 公布了 word2vec 项目。Google 分析了从 Google 新闻中收集的数百万篇文档，以找出哪些单词倾向于出现在相似的句子中。随着时间的推移，一个经训练过的神经网络学会了将相似类别的单词（如狗和猫）放置在向量空间中的相邻位置。</p>
<p>Google 的词向量还具有另一个有趣的特点：你可以使用向量运算“推理”单词。例如，Google 研究人员取出最大的（biggest）向量，减去大的（big）向量，再加上小的（small）向量。与结果向量最接近的词就是最小的（smallest）向量。</p>
<p><img src="https://langgptai.feishu.cn/space/api/box/stream/download/asynccode/?code=OTA2YjVlMTQ2YzlkYWUyNmY1MDc5ZTFhYWJhMjU4MWNfbVdHTnpzN2RZeDVKN1FpcE1SWWUxUXJTeEd0TUI4Y09fVG9rZW46SjBvcGJMUEFvbzlLMkt4eEFpcmN5UmRVbmVkXzE3MjEyNjc5NDk6MTcyMTI3MTU0OV9WNA" alt="img"></p>
<p>你可以使用向量运算来做类比！在这个例子中，大（big）与最大的（biggest）的关系，类似于小（small）与最小的（smallest）的关系。Google 的词向量捕捉到了许多其他的关系：</p>
<ul>
<li>瑞士人与瑞士类似于柬埔寨人与柬埔寨——国籍</li>
<li>巴黎与法国类似于柏林与德国——首都</li>
<li>不道德的与道德的类似于可能的与不可能的——反义词</li>
<li>Mouse（老鼠）与 mice（老鼠的复数）类似于 dollar（美元）与 dollars（美元的复数）——复数形式</li>
<li>男人与女人类似于国王与女王——性别角色</li>
</ul>
<p>因为这些向量是从人们使用语言的方式中构建的，它们反映了许多存在于人类语言中的偏见。例如，在某些词向量模型中，（医生）减去（男人）再加上（女人）等于（护士）。减少这种偏见是一个很新颖的研究领域。</p>
<p>尽管如此，词向量是语言模型的一个有用的基础，它们编码了词之间微妙但重要的关系信息。如果一个语言模型学到了关于猫的一些知识（例如，它有时会去看兽医），那同样的事情很可能也适用于小猫或狗。如果模型学到了关于巴黎和法国之间的关系（例如，它们共用一种语言），那么柏林和德国以及罗马和意大利的关系很可能是一样的。</p>
<h1 id="2、词的意义取决于上下文"><a href="#2、词的意义取决于上下文" class="headerlink" title="2、词的意义取决于上下文"></a>2、词的意义取决于上下文</h1><p>像这样简单的词向量方案并没有捕获到自然语言的一个重要事实：词通常有多重含义。</p>
<p>例如，单词“bank”可以指金融机构或河岸。或者考虑以下句子：</p>
<ul>
<li>John picks up a <strong>magazine</strong>（约翰拿起一本杂志）。</li>
<li>Susan works for a <strong>magazine</strong>（苏珊为一家杂志工作）。</li>
</ul>
<p>这些句子中，“magazine”的含义相关但又有不同。约翰拿起的是一本实体杂志，而苏珊为一家出版实体杂志的机构工作。</p>
<p>当一个词有两个无关的含义时，语言学家称之为同音异义词（homonyms）。当一个词有两个紧密相关的意义时，如“magazine”，语言学家称之为多义词（polysemy）。</p>
<p>像 ChatGPT 这样的语言模型能够根据单词出现的上下文以不同的向量表示同一个词。有一个针对“bank（金融机构）”的向量，还有一个针对“bank（河岸）”的向量。有一个针对“magazine（实体出版物）”的向量，还有一个针对“magazine（出版机构）”的向量。正如你预想的那样，对于多义词的含义，语言模型使用的向量更相似，而对于同音异义词的含义，使用的向量则不太相似。</p>
<p>到目前为止，我们还没有解释语言模型是如何做到这一点——很快会进入这个话题。不过，我们正在详细说明这些向量表示，这对理解语言模型的工作原理非常重要。</p>
<p>传统软件的设计被用于处理明确的数据。如果你让计算机计算“2+3”，关于 2、+或 3 的含义不存在歧义问题。但自然语言中的歧义远不止同音异义词和多义词：</p>
<ul>
<li>在“the customer asked the mechanic to fix <strong>his</strong> car（顾客请修理工修理他的车）”中，“his”是指顾客还是修理工？</li>
<li>在“the professor urged the student to do <strong>her</strong> homework（教授催促学生完成她的家庭作业）”中，“her”是指教授还是学生？</li>
<li>在“fruit <strong>flies</strong> like a banana”中，“flies”是一个动词（指在天空中飞的水果像一只香蕉）还是一个名词（指喜欢香蕉的果蝇）？</li>
</ul>
<p>人们根据上下文来解决这类歧义，但并没有简单或明确的规则。相反，这需要理解关于这个世界的实际情况。你需要知道修理工通常会修理顾客的汽车，学生通常完成自己的家庭作业，水果通常不会飞。</p>
<p>词向量为语言模型提供了一种灵活的方式，以在特定段落的上下文中表示每个词的准确含义。现在让我们看看它们是如何做到这一点的。</p>
<h1 id="3、将词向量转化为词预测"><a href="#3、将词向量转化为词预测" class="headerlink" title="3、将词向量转化为词预测"></a><strong>3、将<strong><strong>词向量</strong></strong>转化为词预测</strong></h1><p>ChatGPT 原始版本背后的 GPT-3 模型，由数十个神经网络层组成。每一层接受一系列向量作为输入——输入文本中的每个词对应一个向量——并添加信息以帮助澄清该词的含义，并且更好地预测接下来可能出现的词。</p>
<p>让我们从一个简单的事例说起。</p>
<p><img src="https://langgptai.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTBjMWMwYTdhNjNjNjg4ODQ3OWIxMjAzMzQyYTg1MzdfVWhBcWE1QTAzVWRaekhMTDM4Mmc4emVwUTN3aVFSOEtfVG9rZW46Qk0yOGJCZkpyb3RwYkR4cTdFNGNMUXVUbnE0XzE3MjEyNjc5NDk6MTcyMTI3MTU0OV9WNA" alt="img"></p>
<p>LLM 的每个层都是一个 Transformer，2017 年，Google 在一篇里程碑的论文中首次介绍了这一神经网络结构。</p>
<p>在图表底部，模型的输入文本是“John wants his bank to cash the（约翰想让他的银行兑现）”， 这些单词被表示为 word2vec 风格的向量，并传送至第一个 Transformer。这个 Transformer 确定了 wants 和 cash 都是动词（这两个词也可以是名词）。我们用小括号中的红色文本表示这一附加的上下文，但实际上模型会通过修改词向量的方式来存储这一信息，这种方式对人类来说很难解释。这些新的向量被称为隐藏状态（hidden state），并传递给下一个 Transformer。</p>
<p>第二个 Transformer 添加了另外两个上下文信息：它澄清了 bank 是指金融机构（financial institution）而不是河岸，并且 his 是指 John 的代词。第二个 Transformer 产生了另一组隐藏状态向量，这一向量反映的是该模型之前所学习的所有信息。</p>
<p>上述图表描绘的是一个纯假设的 LLM，所以不要对细节过于较真。真实的 LLM 往往有更多层。例如，最强大的 GPT-3 版本有 96 层。</p>
<p>研究表明（<em><a target="_blank" rel="noopener" href="https://arxiv.org/abs/1905.05950">https://arxiv.org/abs/1905.05950</a></em>），<strong>前几层专注于理解句子的语法并解决上面所示的歧义。后面的层（为保持图表大小的可控性上述图标没有显示）则致力于对整个段落的高层次理解</strong>。</p>
<p>例如，当 LLM“阅读”一篇短篇小说时，它似乎会记住关于故事角色的各种信息：性别和年龄、与其他角色的关系、过去和当前的位置、个性和目标等等。</p>
<p><strong>研究人员并不完全了解</strong> <strong>LLM</strong> <strong>是如何跟踪这些信息的，但从逻辑上讲，模型在各层之间传递时信息时必须通过修改隐藏状态向量来实现</strong>。现代 LLM 中的向量维度极为庞大，这有利于表达更丰富的语义信息。</p>
<p>例如，GPT-3 最强大的版本使用有 12288 个维度的词向量，也就是说，每个词由一个包含 12288 个的数字列表表示。这比 Google 在 2013 年提出的 word2vec 方案要大 20 倍。你可以把所有这些额外的维度看作是 GPT-3 可以用来记录每个词的上下文的一种“暂存空间（scratch space）”。较早层所做的信息笔记可以被后来的层读取和修改，使模型逐渐加深对整篇文章的理解。</p>
<p>因此，假设我们将上面的图表改为，描述一个 96 层的语言模型来解读一个 1000 字的故事。第 60 层可能包括一个用于约翰（John）的向量，带有一个表示为“（主角，男性，嫁给谢丽尔，唐纳德的表弟，来自明尼苏达州，目前在博伊西，试图找到他丢失的钱包）”的括号注释。同样，所有这些事实（可能还有更多）都会以一个包含 12288 个数字列表的形式编码，这些数字对应于词 John。或者，该故事中的某些信息可能会编码在 12288 维的向量中，用于谢丽尔、唐纳德、博伊西、钱包或其他词。</p>
<p>这样做的目标是，让网络的第 96 层和最后一层输出一个包含所有必要信息的隐藏状态，以预测下一个单词。</p>
<h1 id="4、注意力机制"><a href="#4、注意力机制" class="headerlink" title="4、注意力机制"></a>4、注意力机制</h1><p>现在让我们谈谈每个 Transformer 内部发生的情况。Transformer 在更新输入段落的每个单词的隐藏状态时有两个处理过程：</p>
<ol>
<li>在注意力步骤中，词汇会“观察周围”以查找具有相关背景并彼此共享信息的其他词。</li>
<li>在前馈步骤中，每个词会“思考”之前注意力步骤中收集到的信息，并尝试预测下一个单词。</li>
</ol>
<p>当然，执行这些步骤的是网络，而不是个别的单词。但我们用这种方式表述是为了强调 Transformer 是以单词作为这一分析的基本单元，而不是整个句子或段落。这种方法使得 LLM 能够充分利用现代 GPU 芯片的大规模并行处理能力。它还帮助 LLM 扩展到包含成千上万个词的长段落。而这两个方面都是早期语言模型面临的挑战。</p>
<p><strong>你可以将<strong><strong>注意力机制</strong></strong>看作是单词之间的一个撮合服务</strong>。每个单词都会制作一个检查表（称为查询向量），描述它寻找的词的特征。每个词还会制作一个检查表（称为关键向量），描述它自己的特征。神经网络通过将每个关键向量与每个查询向量进行比较（通过计算点积）来找到最佳匹配的单词。一旦找到匹配项，它将从产生关键向量的单词传递相关信息到产生查询向量的单词。</p>
<p>例如，在前面的部分中，我们展示了一个假设的 Transformer 模型，它发现在部分句子“John wants his bank to cash the”中，“his（他的）”指的是“John（约翰）”。在系统内部，过程可能是这样的：“his”的查询向量可能会有效地表示为“我正在寻找：描述男性的名词”。“John”的关键向量可能会有效地表示为“我是一个描述男性的名词”。网络会检测到这两个向量匹配，并将关于”John”的向量信息转移给“his”的向量。</p>
<p>每个注意力层都有几个“注意力头”，这意味着，这个信息交换过程在每一层上会多次进行（并行）。每个注意头都专注于不同的任务：</p>
<ul>
<li>一个注意头可能会将代词与名词进行匹配，就像我们之前讨论的那样。</li>
<li>另一个注意头可能会处理解析类似”bank”这样的一词多义的含义。</li>
<li>第三个注意力头可能会将“Joe Biden”这样的两个单词短语链接在一起。</li>
</ul>
<p>诸如此类的注意力头经常按顺序操作，一个注意力层中的注意力操作结果成为下一层中一个注意力头的输入。事实上，我们刚才列举的每个任务可能都需要多个注意力头，而不仅仅是一个。GPT-3 的最大版本有 96 个层，每个层有 96 个注意力头，因此，每次预测一个新词时，GPT-3 将执行 9216 个注意力操作。</p>
<h1 id="5、一个真实世界的例子"><a href="#5、一个真实世界的例子" class="headerlink" title="5、一个真实世界的例子"></a>5、<strong>一个真实世界的例子</strong></h1><p>在上述两节内容中，我们展示了注意力头的工作方式的理想化版本。现在让我们来看一下关于真实语言模型内部运作的研究。</p>
<p>去年，研究人员在 Redwood Research 研究了 GPT-2，即 ChatGPT 的前身，对于段落“When Mary and John went to the store， John gave a drink to（当玛丽和约翰去商店，约翰把一杯饮料给了）”预测下一个单词的过程。</p>
<p>GPT-2 预测下一个单词是 Mary（玛丽）。研究人员发现有三种类型的注意力头对这个预测做出了贡献：</p>
<ul>
<li>他们称之为名称移动头（Name Mover Head）的三个注意力头将信息从 Mary 向量复制到最后的输入向量（to 这个词对应的向量）。GPT-2 使用此最右向量中的信息来预测下一个单词。</li>
<li>神经网络是如何决定 Mary 是正确的复制词？通过 GPT-2 的计算过程进行逆向推导，科学家们发现了一组他们称之为主语抑制头（Subject Inhibition Head）的四个注意头，它们标记了第二个 John 向量，阻止名称移动头复制 John 这个名字。</li>
<li>主语抑制头是如何知道不应该复制 John？团队进一步向后推导，发现了他们称为重复标记头（Duplicate Token Heads）的两个注意力头。他们将第二个 John 向量标记为第一个 John 向量的重复副本，这帮助主语抑制头决定不应该复制 John。</li>
</ul>
<p>简而言之，这九个注意力头使得 GPT-2 能够理解“John gave a drink to John（约翰给了约翰一杯饮料”没有意义，而是选择了“John gave a drink to Mary（约翰给了玛丽一杯饮料）”。</p>
<p>这个例子侧面说明了要完全理解 LLM 会有多么困难。由五位研究人员组成的 Redwood 团队曾发表了一篇 25 页的论文，解释了他们是如何识别和验证这些注意力头。然而，即使他们完成了所有这些工作，我们离对于为什么 GPT-2 决定预测“Mary”作为下一个单词的全面解释还有很长的路要走。</p>
<p>例如，模型是如何知道下一个单词应该是某个人的名字而不是其他类型的单词？很容易想到，在类似的句子中，Mary 不会是一个好的下一个预测词。例如，在句子“when Mary and John went to the restaurant， John gave his keys to（当玛丽和约翰去餐厅时，约翰把钥匙给了）”中，逻辑上，下一个词应该是“the valet（代客停车员）”。</p>
<p>假设计算机科学家们进行充足的研究，他们可以揭示和解释 GPT-2 推理过程中的其他步骤。最终，他们可能能够全面理解 GPT-2 是如何决定“Mary”是该句子最可能的下一个单词。但这可能需要数月甚至数年的额外努力才能理解一个单词的预测情况。</p>
<p>ChatGPT 背后的语言模型——GPT-3 和 GPT-4——比 GPT-2 更庞大和复杂，相比 Redwood 团队研究的简单句子，它们能够完成更复杂的推理任务。因此，完全解释这些系统的工作将是一个巨大的项目，人类不太可能在短时间内完成。</p>
<h1 id="6、前馈步骤"><a href="#6、前馈步骤" class="headerlink" title="6、前馈步骤"></a><strong>6、前馈步骤</strong></h1><p>在注意力头在词向量之间传输信息后，前馈网络会“思考”每个词向量并尝试预测下一个词。在这个阶段，单词之间没有交换信息，前馈层会独立地分析每个单词。然而，前馈层可以访问之前由注意力头复制的任何信息。以下是 GPT-3 最大版本的前馈层结构。</p>
<p><img src="https://langgptai.feishu.cn/space/api/box/stream/download/asynccode/?code=ODEzNWNkNGE1NWRkNzAzYWU0MDAyYjY3NTYzNjczMGFfWVlzbDZkM0JuUTRkWlNuQkhaQTRnZHRTaFVRbVBua1RfVG9rZW46RGZpSmJ6cWlCb0RUcWV4YVVrSWM0RHRIbnBiXzE3MjEyNjc5NDk6MTcyMTI3MTU0OV9WNA" alt="img"></p>
<p>绿色和紫色的圆圈表示神经元：它们是计算其输入加权和的数学函数。</p>
<p>前馈层之所以强大，是因为它有大量的连接。我们使用三个神经元作为输出层，六个神经元作为隐藏层来绘制这个网络，但是 GPT-3 的前馈层要大得多：输出层有 12288 个神经元（对应模型的 12288 维词向量），隐藏层有 49152 个神经元。</p>
<p>所以在最大版本的 GPT-3 中，隐藏层有 49152 个神经元，每个神经元有 12288 个输入值（因此每个神经元有 12288 个权重参数），并且还有 12288 输出神经元，每个神经元有 49152 个输入值（因此每个神经元有 49152 个权重参数）。这意味着，每个前馈层有 49152<em>12288+12288</em>49152&#x3D;12 亿个权重参数。并且有 96 个前馈层，总共有 12 亿*96&#x3D;1160 亿个参数！这相当于具有 1750 亿参数的 GPT-3 近三分之二的参数量。</p>
<p>2020 年的一篇论文（<em><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2012.14913">https://arxiv.org/abs/2012.14913</a></em>）中，来自特拉维夫大学的研究人员发现，前馈层通过模式匹配进行工作：隐藏层中的每个神经元都能匹配输入文本中的特定模式。下面是一个 16 层版本的 GPT-2 中的一些神经元匹配的模式：</p>
<ul>
<li>第 1 层的神经元匹配以“substitutes”结尾的词序列。</li>
<li>第 6 层的神经元匹配与军事有关并以“base”或“bases”结尾的词序列。</li>
<li>第 13 层的神经元匹配以时间范围结尾的序列，比如“在下午 3 点到 7 点之间”或者“从周五晚上 7 点到”。</li>
<li>第 16 层的神经元匹配与电视节目相关的序列，例如“原始的 NBC 日间版本，已存档”或者“时间延迟使该集的观众增加了 57%。”</li>
</ul>
<p>正如你所看到的，在后面的层中，模式变得更抽象。早期的层倾向于匹配特定的单词，而后期的层则匹配属于更广泛语义类别的短语，例如电视节目或时间间隔。</p>
<p>这很有趣，因为如前所述，前馈层每次只能检查一个单词。因此，当将序列“原始的 NBC 日间版本，已存档”分类为“与电视相关”时，它只能访问“已存档”这个词的向量，而不是 NBC 或日间等词汇。可以推断，前馈层之所以可以判断“已存档”是电视相关序列的一部分，是因为注意力头先前将上下文信息移到了“已存档”的向量中。</p>
<p>当一个神经元与其中一个模式匹配时，它会向词向量中添加信息。虽然这些信息并不总是容易解释，但在许多情况下，你可以将其视为对下一个词的临时预测。</p>
<h1 id="7、使用向量运算进行前馈网络的推理"><a href="#7、使用向量运算进行前馈网络的推理" class="headerlink" title="7、使用向量运算进行前馈网络的推理"></a><strong>7、使用向量运算进行前馈网络的推理</strong></h1><p>布朗大学最近的研究（<em><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2305.16130">https://arxiv.org/abs/2305.16130</a></em>）展示了前馈层如何帮助预测下一个单词的优雅例子。我们之前讨论过 Google 的 word2vec 研究，显示可以使用向量运算进行类比推理。例如，柏林-德国+法国&#x3D;巴黎。</p>
<p>布朗大学的研究人员发现，前馈层有时使用这种准确的方法来预测下一个单词。例如，他们研究了 GPT-2 对以下提示的回应：“问题：法国的首都是什么？回答：巴黎。问题：波兰的首都是什么？回答：华沙。</p>
<p>团队研究了一个包含 24 个层的 GPT-2 版本。在每个层之后，布朗大学的科学家们探测模型，观察它对**<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU5ODY2MTk3Nw==&mid=2247491741&idx=1&sn=125132a0c895fbaf0606f0097cf95998&chksm=fe426eabc935e7bd81c3403dcc85eed4404f32f713862217c526596d86d728e1d94346cbbe43&scene=21#wechat_redirect">下一个词元（token）的最佳猜测</a>**。在前 15 层，最高可能性的猜测是一个看似随机的单词。在第 16 层和第 19 层之间，模型开始预测下一个单词是波兰——不正确，但越来越接近正确。然后在第 20 层，最高可能性的猜测变为华沙——正确的答案，并在最后四层保持不变。</p>
<p>布朗大学的研究人员发现，第 20 个前馈层通过添加一个将国家向量映射到其对应首都的向量，从而将波兰转换为华沙。将相同的向量添加到中国时，答案会得到北京。</p>
<p>同一模型中的前馈层使用向量运算将小写单词转换为大写单词，并将现在时的单词转换为过去时的等效词。</p>
<h1 id="8、注意力层和前馈层有不同的功能"><a href="#8、注意力层和前馈层有不同的功能" class="headerlink" title="8、注意力层和前馈层有不同的功能"></a><strong>8、注意力层和前馈层有不同的功能</strong></h1><p>到目前为止，我们已经看到了 GPT-2 单词预测的两个实际示例：注意力头帮助预测约翰给玛丽一杯饮料；前馈层帮助预测华沙是波兰的首都。</p>
<p>在第一个案例中，玛丽来自用户提供的提示。但在第二个案例中，华沙并没有出现在提示中。相反，GPT-2 必须“记住”华沙是波兰的首都，这个信息是从训练数据中学到的。</p>
<p>当布朗大学的研究人员禁用将波兰转换为华沙的前馈层时，模型不再预测下一个词是华沙。但有趣的是，如果他们接着在提示的开头加上句子“波兰的首都是华沙”，那么 GPT-2 就能再次回答这个问题。这可能是因为 GPT-2 使用注意力机制从提示中提取了华沙这个名字。</p>
<p>这种分工更广泛地表现为：<strong>注意力机制****从提示的较早部分检索信息，而前馈层使语言模型能够“记住”未在提示中出现的信息</strong>。</p>
<p><strong>事实上，可以将前馈层视为模型从<strong><strong>训练数据</strong></strong>中学到的信息的数据库</strong>。靠前的前馈层更可能编码与特定单词相关的简单事实，例如“特朗普经常在唐纳德之后出现”。靠后的层则编码更复杂的关系，如“添加这个向量以将一个国家转换为其首都。</p>
<h1 id="9、语言模型的训练方式"><a href="#9、语言模型的训练方式" class="headerlink" title="9、语言模型的训练方式"></a><strong>9、语言模型的训练方式</strong></h1><p>许多早期的机器学习算法需要人工标记的训练示例。例如，训练数据可能是带有人工标签（“狗”或“猫”）的狗或猫的照片。需要标记数据的需求，使得人们创建足够大的数据集以训练强大模型变得困难且昂贵。</p>
<p>LLM 的一个关键创新之处在于，它们不需要显式标记的数据。相反，它们通过尝试预测文本段落中下一个单词来学习。几乎任何书面材料都适用于训练这些模型——从维基百科页面到新闻文章再到计算机代码。</p>
<p>举例来说，LLM 可能会得到输入“I like my coffee with cream and（我喜欢在咖啡里加奶油和）”，并试图预测“sugar（糖）”作为下一个单词。一个新的初始化语言模型在这方面表现很糟糕，因为它的每个权重参数——GPT-3 最强大的版本高达 1750 亿个参数——最初基本上都是从一个随机数字开始。但是随着模型看到更多的例子——数千亿个单词——这些权重逐渐调整以做出更好的预测。</p>
<p>下面用一个类比来说明这个过程是如何进行的。假设你要洗澡，希望水温刚刚好：不太热，也不太冷。你以前从未用过这个水龙头，所以你随意调整水龙头把手的方向，并触摸水的温度。如果太热或太冷，你会向相反的方向转动把手，当接近适当的水温时，你对把手所做的调整幅度就越小。</p>
<p>现在，让我们对这个类比做几个改动。首先，想象一下有 50257 个水龙头，每个水龙头对应一个不同的单词，比如”the”、”cat”或”bank”。你的目标是，只让与序列中下一个单词相对应的水龙头里出水。</p>
<p>其次，水龙头后面有一堆互联的管道，并且这些管道上还有一堆阀门。所以如果水从错误的水龙头里出来，你不能只调整水龙头上的旋钮。你要派遣一支聪明的松鼠部队去追踪每条管道，并沿途调整它们找到的每个阀门。 这变得很复杂，由于同一条管道通常供应多个水龙头，所以需要仔细思考如何确定要拧紧和松开哪些阀门，以及程度多大。</p>
<p>显然，如果字面理解这个例子，就变得很荒谬。建立一个拥有 1750 亿个阀门的管道网络既不现实也没用。但是由于摩尔定律，计算机可以并且确实以这种规模运行。</p>
<p>截止目前，在本文中所讨论的 LLM 的所有部分——前馈层的神经元和在单词之间传递上下文信息的注意力头——都被实现为一系列简单的数学函数（主要是矩阵乘法），其行为由可调整的权重参数来确定。就像我故事中的松鼠松紧阀门来控制水流一样，训练算法通过增加或减小语言模型的权重参数来控制信息在神经网络中的流动。 训练过程分为两个步骤。首先进行“前向传播（forward pass）”，打开水源并检查水是否从正确的水龙头流出。然后关闭水源，进行“反向传播（backwards pass）”，松鼠们沿着每根管道竞速，拧紧或松开阀门。在数字神经网络中，松鼠的角色由一个称为反向传播的算法来扮演，该算法“逆向（walks backwards）”通过网络，使用微积分来估计需要改变每个权重参数的程度。 完成这个过程——对一个示例进行前向传播，然后进行后向传播来提高网络在该示例上的性能——需要进行数百亿次数学运算。而像 GPT-3 这种大模型的训练需要重复这个过程数十亿次——对每个训练数据的每个词都要进行训练。OpenAI 估计，训练 GPT-3 需要超过 3000 亿万亿次浮点计算——这需要几十个高端计算机芯片运行数月。</p>
<h1 id="10、GPT-3-的惊人性能"><a href="#10、GPT-3-的惊人性能" class="headerlink" title="10、GPT-3 的惊人性能"></a><strong>10、GPT-3 的惊人性能</strong></h1><p>你可能会对训练过程能够如此出色地工作感到惊讶。ChatGPT 可以执行各种复杂的任务——撰写文章、进行类比和甚至编写计算机代码。那么，这样一个简单的学习机制是如何产生如此强大的模型？</p>
<p><strong>一个原因是规模</strong>。很难过于强调像 GPT-3 这样的模型看到的示例数量之多。GPT-3 是在大约 5000 亿个单词的语料库上进行训练的。相比之下，一个普通的人类孩子在 10 岁之前遇到的单词数量大约是 1 亿个。</p>
<p>在过去的五年中，OpenAI 不断增大其语言模型的规模。在一篇广为传阅的 2020 年论文中（<em><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/2001.08361.pdf">https://arxiv.org/pdf/2001.08361.pdf</a></em>），OpenAI 报告称，他们的语言模型的准确性与模型规模、数据集规模以及用于训练的计算量呈幂律关系，一些趋势甚至跨越七个数量级以上”。</p>
<p>模型规模越大，在涉及语言的任务上表现得越好。但前提是，他们需要以类似的倍数增加训练数据量。<strong>而要在更多数据上训练更大的模型，还需要更多的****算力</strong>。</p>
<p>2018 年，OpenAI 发布了第一个大模型 GPT-1 于。它使用了 768 维的词向量，共有 12 层，总共有 1.17 亿个参数。几个月后，OpenAI 发布了 GPT-2，其最大版本拥有 1600 维的词向量，48 层，总共有 15 亿个参数。2020 年，OpenAI 发布了 GPT-3，它具有 12288 维的词向量，96 层，总共有 1750 亿个参数。</p>
<p>今年，OpenAI 发布了 GPT-4。该公司尚未公布任何架构细节，但业内普遍认为，GPT-4 比 GPT-3 要大得多。每个模型不仅学到了比其较小的前身模型更多的事实，而且在需要某种形式的抽象推理任务上表现出更好的性能。</p>
<p>例如，设想以下故事：一个装满爆米花的袋子。袋子里没有巧克力。然而，袋子上的标签写着“巧克力”而不是“爆米花”。山姆发现了这个袋子。她以前从未见过这个袋子。她看不见袋子里面的东西。她读了标签。</p>
<p>你可能猜到，山姆相信袋子里装着巧克力，并会惊讶地发现里面是爆米花。</p>
<p>心理学家将这种推理他人思维状态的能力研究称为“心智理论（Theory of Mind）”。大多数人从上小学开始就具备这种能力。专家们对于任何非人类动物（例如黑猩猩）是否适用心智理论存在分歧，但基本共识是，它对人类社会认知至关重要。</p>
<p>今年早些时候，斯坦福大学心理学家米 Michal Kosinski 发表了一项研究（<em><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2302.02083">https://arxiv.org/abs/2302.02083</a></em>），研究了 LLM 的能力以解决心智理论任务。他给各种语言模型阅读类似刚刚引述的故事，然后要求它们完成一个句子，比如“她相信袋子里装满了”，正确答案是“巧克力”，但一个不成熟的语言模型可能会说“爆米花”或其他东西。</p>
<p>GPT-1 和 GPT-2 在这个测试中失败了。但是在 2020 年发布的 GPT-3 的第一个版本正确率达到了近 40%，Kosinski 将模型性能水平与三岁儿童相比较。去年 11 月发布的最新版本 GPT-3 将上述问题的正确率提高到了约 90%，与七岁儿童相当。GPT-4 对心智理论问题的回答正确率约为 95%。</p>
<p><img src="https://langgptai.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTRiZjE2NmNjOWY4ZWFlNTgwZGMzMWZjZjRmYjZiYzJfblI3WHM0QnhGOW9vWTM3Qzh3QkRvQjRjT3BvZXBOcnhfVG9rZW46Uk5vQmJ2cGZnb252Zm94UmF4WmNSWTZmbkZ4XzE3MjEyNjc5NDk6MTcyMTI3MTU0OV9WNA" alt="img"></p>
<p>“鉴于这些模型中既没有迹象表明 ToM（心智化能力）被有意设计进去，也没有研究证明科学家们知道如何实现它，这一能力很可能是自发且自主地出现的。这是模型的语言能力不断增强的一个副产品。”Kosinski 写道。</p>
<p>值得注意的是，研究人员并不全都认可这些结果证明了心智理论：例如，对错误信念任务的微小更改导致 GPT-3 的性能大大下降（<em><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2302.08399">https://arxiv.org/abs/2302.08399</a></em>）；而 GPT-3 在测量心智理论的其他任务中的表现更为不稳定（<em><a target="_blank" rel="noopener" href="https://openreview.net/forum?id=e5Yky8Fnvj">https://openreview.net/forum?id=e5Yky8Fnvj</a></em>），正如其中肖恩所写（<em><a target="_blank" rel="noopener" href="https://onlinelibrary.wiley.com/doi/full/10.1111/cogs.13309">https://onlinelibrary.wiley.com/doi/full/10.1111/cogs.13309</a></em>）的那样，成功的表现可能归因于任务中的混淆因素——一种“聪明汉斯（clever Hans，指一匹名为汉斯的马看似能完成一些简单的智力任务，但实际上只是依赖于人们给出的无意识线索）”效应，只不过是出现在了语言模型上而不是马身上。</p>
<p>尽管如此，GPT-3 在几个旨在衡量心智理论的任务上接近人类的表现，这在几年前是无法想象的，并且这与更大的模型通常在需要高级推理的任务中表现更好的观点相一致。</p>
<p>这只是语言模型表现出自发发展出高级推理能力的众多例子之一。今年 4 月，微软的研究人员发表的一篇论文（<em><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2303.12712">https://arxiv.org/abs/2303.12712</a></em>）表示，GPT-4 展示了通用人工智能的初步、诱人的迹象——即以一种复杂、类人的方式思考的能力。</p>
<p>例如，一位研究人员要求 GPT-4 使用一种名为 TiKZ 的晦涩图形编程语言画一只独角兽。GPT-4 回应了几行代码，然后研究人员将这些代码输入 TiKZ 软件。生成的图像虽然粗糙，但清晰地显示出 GPT-4 对独角兽的外观有一定的理解。</p>
<p><img src="https://langgptai.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTMwYjBhNzM4MzhkNjJhZTgzMDdjMDk5ZmNkN2VkNTRfM1NuN2hnNUxvNDRJMnVMSVBBaUhGWGkya2ZpMDJoQ0NfVG9rZW46VkNOY2JxNXQ2b2w0eW94bWplSWNsVnVwbmRnXzE3MjEyNjc5NDk6MTcyMTI3MTU0OV9WNA" alt="img"></p>
<p>研究人员认为，GPT-4 可能以某种方式从训练数据中记住了绘制独角兽的代码，所以他们给它提出了一个后续的挑战：他们修改了独角兽的代码，移除了头角，并移动了一些其他身体部位。然后他们让 GPT-4 把独角兽的头角放回去。GPT-4 通过将头角放在正确的位置上作出了回应：</p>
<p><img src="https://langgptai.feishu.cn/space/api/box/stream/download/asynccode/?code=NTgxODFmMzVkYmY0MTJlMjM1YWI0OTgyNmZjNGE1ZWRfOFZjZ2ZSM1JsQXN6Z2dTc1I1NWFPU1hlVzhlQnpOOGNfVG9rZW46RE9pVWJKWEx6b1pYb2h4bkZ3VGNxS25ObjZmXzE3MjEyNjc5NDk6MTcyMTI3MTU0OV9WNA" alt="img"></p>
<p>尽管作者的测试版本的训练数据完全基于文本，没有包含任何图像，但 GPT-4 似乎仍然能够完成这个任务。不过，通过大量的书面文本训练后，GPT-4 显然学会了推理关于独角兽身体形状的知识。</p>
<p>目前，我们对 LLM 如何完成这样的壮举没有真正的了解。有些人认为，像这样的例子表明模型开始真正理解其训练集中词的含义。其他人坚持认为，语言模型只是“随机鹦鹉（<em><a target="_blank" rel="noopener" href="https://dl.acm.org/doi/abs/10.1145/3442188.3445922">https://dl.acm.org/doi/abs/10.1145/3442188.3445922</a></em>）”，仅仅是重复越来越复杂的单词序列，而并非真正理解它们。</p>
<p>这种辩论指向了一种深刻的哲学争论，可能无法解决。尽管如此，我们认为关注 GPT-3 等模型的经验表现很重要。如果一个语言模型能够在特定类型的问题中始终得到正确答案，并且研究人员有信心排除混淆因素（例如，确保在训练期间该语言模型没有接触到这些问题），<strong>那无论它对语言的理解方式是否与人类完全相同，这都是一个有趣且重要的结果</strong>。</p>
<p>训练下一个词元预测如此有效的另一个可能原因是，<strong>语言本身是可预测的</strong>。语言的规律性通常（尽管并不总是这样）与物质世界的规律性相联系。因此，当语言模型学习单词之间的关系时，通常也在隐含地学习这个世界存在的关系。</p>
<p>此外，预测可能是生物智能以及人工智能的基础。根据 Andy Clark 等哲学家的观点 ，人脑可以被认为是一个“预测机器”，其主要任务是对我们的环境进行预测，然后利用这些预测来成功地驾驭环境。预测对于生物智能和人工智能都至关重要。直观地说，好的预测离不开良好的表示——准确的地图比错误的地图更有可能帮助人们更好地导航。世界是广阔而复杂的，进行预测有助于生物高效定位和适应这种复杂性。</p>
<p>在构建语言模型方面，传统上一个重大的挑战是，找出最有用的表示不同单词的方式，特别是因为许多单词的含义很大程度上取决于上下文。下一个词的预测方法使研究人员能够将其转化为一个经验性问题，以此避开这个棘手的理论难题。</p>
<p>事实证明，如果我们提供足够的数据和计算能力，语言模型能够通过找出最佳的下一个词的预测来学习人类语言的运作方式。不足之处在于，最终得到的系统内部运作方式人类还并不能完全理解。</p>
<p><strong>注释：</strong></p>
<ol>
<li>从技术上说，LLM 的单词片段成为词元，但我们将忽略此实现细节，以使本文保持在可控的长度内（可参考文章《**<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU5ODY2MTk3Nw==&mid=2247491741&idx=1&sn=125132a0c895fbaf0606f0097cf95998&chksm=fe426eabc935e7bd81c3403dcc85eed4404f32f713862217c526596d86d728e1d94346cbbe43&scene=21#wechat_redirect">揭示 GPT Tokenizer 的工作原理</a>**》）。</li>
<li>前馈网络也被称为多层感知器。自 20 世纪 60 年代以来，计算机科学家一直在研究这种类型的神经网络。</li>
<li>从技术上讲，在神经元计算了输入的加权和之后，它将结果传递给激活函数。本文将忽略这个实现细节，完整地解释神经元是如何工作的，请查看：*<a target="_blank" rel="noopener" href="https://arstechnica.com/science/2018/12/how-computers-got-shockingly-good-at-recognizing-images/*%EF%BC%89%E3%80%82">https://arstechnica.com/science/2018/12/how-computers-got-shockingly-good-at-recognizing-images/*）。</a></li>
<li>如果你想了解更多关于反向传播的知识，请查看蒂姆 2018 年关于神经网络如何工作的解释。</li>
<li>在实践中，为了提高计算效率，训练通常是按批次进行的。因此，软件可能会在进行反向传播之前对 32000 个词元进行前向传播。</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Liusf</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/07/19/通俗解构语言大模型的工作原理/">http://example.com/2024/07/19/通俗解构语言大模型的工作原理/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com">Hexo</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="next-post pull-right"><a href="/2024/07/19/%E6%8F%90%E7%A4%BA%E8%AF%8D%E5%B8%82%E5%9C%BA%E5%88%9D%E6%AD%A5%E5%88%86%E6%9E%90/"><span>提示词市场初步分析</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2024 By Liusf</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">粤ICP备2024280235号-1</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>